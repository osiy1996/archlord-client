/*
   AngelCode Scripting Library
   Copyright (c) 2003-2005 Andreas J?sson

   This software is provided 'as-is', without any express or implied 
   warranty. In no event will the authors be held liable for any 
   damages arising from the use of this software.

   Permission is granted to anyone to use this software for any 
   purpose, including commercial applications, and to alter it and 
   redistribute it freely, subject to the following restrictions:

   1. The origin of this software must not be misrepresented; you 
      must not claim that you wrote the original software. If you use
	  this software in a product, an acknowledgment in the product 
	  documentation would be appreciated but is not required.

   2. Altered source versions must be plainly marked as such, and 
      must not be misrepresented as being the original software.

   3. This notice may not be removed or altered from any source 
      distribution.

   The original version of this library can be located at:
   http://www.angelcode.com/angelscript/

   Andreas J?sson
   andreas@angelcode.com
*/


//
// angelscript.h
//
// The script engine interface
//


#ifndef ANGELSCRIPT_H
#define ANGELSCRIPT_H

// AngelScript version

#define ANGELSCRIPT_VERSION        20000
#define ANGELSCRIPT_VERSION_MAJOR  2
#define ANGELSCRIPT_VERSION_MINOR  0
#define ANGELSCRIPT_VERSION_BUILD  0
#define ANGELSCRIPT_VERSION_STRING "2.0.0"

// Data types

class asIScriptEngine;
class asIScriptContext;
class asIOutputStream;
class asIBinaryStream;
typedef unsigned long  asDWORD;
#ifdef __GNUC__
typedef long long asQWORD;
#else
typedef __int64 asQWORD;
#endif
typedef unsigned short asWORD;
typedef unsigned char  asBYTE;
typedef unsigned int   asUINT;

typedef void (*asFUNCTION_t)();

class asCUnknownClass;
typedef void (asCUnknownClass::*asMETHOD_t)();

union asUPtr
{
	asMETHOD_t   mthd;
	asFUNCTION_t func;
};

#define asFUNCTION(f) asFunctionPtr((void (*)())(f))
#define asFUNCTIONPR(f,p,r) asFunctionPtr((void (*)())((r (*)p)(f)))
#define asMETHOD(c,m) asSMethodPtr<sizeof(void (c::*)())>::Convert((void (c::*)())(&c::m))
#define asMETHODPR(c,m,p,r) asSMethodPtr<sizeof(void (c::*)())>::Convert((r (c::*)p)(&c::m))

// API functions

// ANGELSCRIPT_EXPORT is defined when compiling the dll or lib
// ANGELSCRIPT_DLL_LIBRARY_IMPORT is defined when dynamically linking to the 
// dll through the link lib automatically generated by MSVC++
// ANGELSCRIPT_DLL_MANUAL_IMPORT is defined when manually loading the dll
// Don't define anything when linking statically to the lib

#ifdef WIN32
  #ifdef ANGELSCRIPT_EXPORT
    #define AS_API __declspec(dllexport)
  #elif defined ANGELSCRIPT_DLL_LIBRARY_IMPORT
    #define AS_API __declspec(dllimport)
  #else // statically linked library
    #define AS_API 
  #endif
#else
  #define AS_API
#endif

#ifndef ANGELSCRIPT_DLL_MANUAL_IMPORT
extern "C"
{
	// Engine
	AS_API asIScriptEngine * asCreateScriptEngine(asDWORD version);
	AS_API const char * asGetLibraryVersion();

	// Context
	AS_API asIScriptContext * asGetActiveContext();

	// Thread support
	AS_API int asThreadCleanup();
}
#endif

// Interface declarations

class asIScriptEngine
{
public:
	// Memory management
	virtual int AddRef() = 0;
	virtual int Release() = 0;

	// Engine configuration
	virtual int RegisterObjectType(const char *name, int byteSize, asDWORD flags) = 0;
	virtual int RegisterObjectProperty(const char *obj, const char *declaration, int byteOffset) = 0;
	virtual int RegisterObjectMethod(const char *obj, const char *declaration, asUPtr funcPointer, asDWORD callConv) = 0;
	virtual int RegisterObjectBehaviour(const char *datatype, asDWORD behaviour, const char *declaration, asUPtr funcPointer, asDWORD callConv) = 0;

	virtual int RegisterGlobalProperty(const char *declaration, void *pointer) = 0;
	virtual int RegisterGlobalFunction(const char *declaration, asUPtr funcPointer, asDWORD callConv) = 0;
	virtual int RegisterGlobalBehaviour(asDWORD behaviour, const char *declaration, asUPtr funcPointer, asDWORD callConv) = 0;

	virtual int RegisterStringFactory(const char *datatype, asUPtr factoryFunc, asDWORD callConv) = 0;

	// Script modules
	virtual int AddScriptSection(const char *module, const char *name, const char *code, int codeLength, int lineOffset = 0) = 0;
	virtual int Build(const char *module, asIOutputStream *out = 0) = 0;
    virtual int Discard(const char *module) = 0;
	virtual int GetModuleIndex(const char *module) = 0;
	virtual const char *GetModuleNameFromIndex(int index, int *length = 0) = 0;

	// Script functions
	virtual int GetFunctionCount(const char *module) = 0;
	virtual int GetFunctionIDByIndex(const char *module, int index) = 0;
	virtual int GetFunctionIDByName(const char *module, const char *name) = 0;
	virtual int GetFunctionIDByDecl(const char *module, const char *decl) = 0;
	virtual const char *GetFunctionDeclaration(int funcID, int *length = 0) = 0;
	virtual const char *GetFunctionName(int funcID, int *length = 0) = 0;

	// Script global variables
	virtual int GetGlobalVarCount(const char *module) = 0;
	virtual int GetGlobalVarIDByIndex(const char *module, int index) = 0;
	virtual int GetGlobalVarIDByName(const char *module, const char *name) = 0;
	virtual int GetGlobalVarIDByDecl(const char *module, const char *decl) = 0;
	virtual const char *GetGlobalVarDeclaration(int gvarID, int *length = 0) = 0;
	virtual const char *GetGlobalVarName(int gvarID, int *length = 0) = 0;
	virtual int GetGlobalVarPointer(int gvarID, void **pointer) = 0;

	// Dynamic binding between modules
	virtual int GetImportedFunctionCount(const char *module) = 0;
	virtual int GetImportedFunctionIndexByDecl(const char *module, const char *decl) = 0;
	virtual const char *GetImportedFunctionDeclaration(const char *module, int importIndex, int *length = 0) = 0;
	virtual const char *GetImportedFunctionSourceModule(const char *module, int importIndex, int *length = 0) = 0;
	virtual int BindImportedFunction(const char *module, int importIndex, int funcID) = 0;
	virtual int UnbindImportedFunction(const char *module, int importIndex) = 0;

	virtual int BindAllImportedFunctions(const char *module) = 0;
	virtual int UnbindAllImportedFunctions(const char *module) = 0;

	// Script execution
	virtual int SetDefaultContextStackSize(asUINT initial, asUINT maximum) = 0;
	virtual int CreateContext(asIScriptContext **context) = 0;

	// String interpretation
	virtual int ExecuteString(const char *module, const char *script, asIOutputStream *out = 0, asIScriptContext **ctx = 0, asDWORD flags = 0) = 0;

	// Bytecode Saving/Loading
	virtual int SaveByteCode(const char *module, asIBinaryStream *out) = 0;
	virtual int LoadByteCode(const char *module, asIBinaryStream *in) = 0;
	
protected:
	virtual ~asIScriptEngine() {};
};

class asIScriptContext
{
public:
	// Memory management
	virtual int AddRef() = 0;
	virtual int Release() = 0;

	// Engine
	virtual asIScriptEngine *GetEngine() = 0;

	// Script context
	virtual int GetState() = 0;

	virtual int Prepare(int funcID) = 0;

	virtual int SetArgDWord(asUINT arg, asDWORD value) = 0;
	virtual int SetArgQWord(asUINT arg, asQWORD value) = 0;
	virtual int SetArgFloat(asUINT arg, float value) = 0;
	virtual int SetArgDouble(asUINT arg, double value) = 0;
	virtual int SetArgObject(asUINT arg, void *obj) = 0;

	virtual asDWORD GetReturnDWord() = 0;
	virtual asQWORD GetReturnQWord() = 0;
	virtual float   GetReturnFloat() = 0;
	virtual double  GetReturnDouble() = 0;
	virtual void   *GetReturnObject() = 0;

	virtual int Execute() = 0;
	virtual int ExecuteStep(asDWORD flag) = 0;
	virtual int Abort() = 0;
	virtual int Suspend() = 0;

	virtual int GetCurrentLineNumber() = 0;
	virtual int GetCurrentFunction() = 0;

	// Exception handling
	virtual int SetException(const char *string) = 0;
	virtual int GetExceptionLineNumber() = 0;
	virtual int GetExceptionFunction() = 0;
	virtual const char *GetExceptionString(int *length = 0) = 0;
	
protected:
	virtual ~asIScriptContext() {};
};

class asIOutputStream
{
public:
	virtual void Write(const char *text) = 0;
};

class asIBinaryStream
{
public:
	virtual void Read(void *ptr, int size) = 0;
	virtual void Write(void *ptr, int size) = 0;
};

// Enumerations and constants

// Calling conventions and flags

const asDWORD asCALL_CDECL            = 0;
const asDWORD asCALL_STDCALL          = 1;
const asDWORD asCALL_THISCALL         = 2;
const asDWORD asCALL_CDECL_OBJLAST    = 3;
const asDWORD asCALL_CDECL_OBJFIRST   = 4;

// Object type flags

const asDWORD asOBJ_CLASS             = 1;
const asDWORD asOBJ_CLASS_CONSTRUCTOR = 2;
const asDWORD asOBJ_CLASS_DESTRUCTOR  = 4;
const asDWORD asOBJ_CLASS_ASSIGNMENT  = 8;
const asDWORD asOBJ_CLASS_C           = (asOBJ_CLASS + asOBJ_CLASS_CONSTRUCTOR);
const asDWORD asOBJ_CLASS_CD          = (asOBJ_CLASS + asOBJ_CLASS_CONSTRUCTOR + asOBJ_CLASS_DESTRUCTOR);
const asDWORD asOBJ_CLASS_CA          = (asOBJ_CLASS + asOBJ_CLASS_CONSTRUCTOR + asOBJ_CLASS_ASSIGNMENT);
const asDWORD asOBJ_CLASS_CDA         = (asOBJ_CLASS + asOBJ_CLASS_CONSTRUCTOR + asOBJ_CLASS_DESTRUCTOR + asOBJ_CLASS_ASSIGNMENT);
const asDWORD asOBJ_CLASS_D           = (asOBJ_CLASS + asOBJ_CLASS_DESTRUCTOR);
const asDWORD asOBJ_CLASS_A           = (asOBJ_CLASS + asOBJ_CLASS_ASSIGNMENT);
const asDWORD asOBJ_CLASS_DA          = (asOBJ_CLASS + asOBJ_CLASS_DESTRUCTOR + asOBJ_CLASS_ASSIGNMENT);
const asDWORD asOBJ_PRIMITIVE         = 16;
const asDWORD asOBJ_FLOAT             = 17;

// Behaviours

const asDWORD asBEHAVE_CONSTRUCT     = 0;
const asDWORD asBEHAVE_DESTRUCT      = 1;
const asDWORD asBEHAVE_FIRST_ASSIGN  = 2;
 const asDWORD asBEHAVE_ASSIGNMENT    = 2;
 const asDWORD asBEHAVE_ADD_ASSIGN    = 3;
 const asDWORD asBEHAVE_SUB_ASSIGN    = 4;
 const asDWORD asBEHAVE_MUL_ASSIGN    = 5;
 const asDWORD asBEHAVE_DIV_ASSIGN    = 6;
 const asDWORD asBEHAVE_MOD_ASSIGN    = 7;
 const asDWORD asBEHAVE_OR_ASSIGN     = 8;
 const asDWORD asBEHAVE_AND_ASSIGN    = 9;
 const asDWORD asBEHAVE_XOR_ASSIGN    = 10;
 const asDWORD asBEHAVE_SLL_ASSIGN    = 11;
 const asDWORD asBEHAVE_SRL_ASSIGN    = 12;
 const asDWORD asBEHAVE_SRA_ASSIGN    = 13;
const asDWORD asBEHAVE_LAST_ASSIGN   = 13;
const asDWORD asBEHAVE_FIRST_DUAL    = 14;
 const asDWORD asBEHAVE_ADD           = 14;
 const asDWORD asBEHAVE_SUBTRACT      = 15;
 const asDWORD asBEHAVE_MULTIPLY      = 16;
 const asDWORD asBEHAVE_DIVIDE        = 17;
 const asDWORD asBEHAVE_MODULO        = 18;
 const asDWORD asBEHAVE_EQUAL         = 19;
 const asDWORD asBEHAVE_NOTEQUAL      = 20;
 const asDWORD asBEHAVE_LESSTHAN      = 21;
 const asDWORD asBEHAVE_GREATERTHAN   = 22;
 const asDWORD asBEHAVE_LEQUAL        = 23;
 const asDWORD asBEHAVE_GEQUAL        = 24;
 const asDWORD asBEHAVE_LOGIC_OR      = 25;
 const asDWORD asBEHAVE_LOGIC_AND     = 26;
 const asDWORD asBEHAVE_BIT_OR        = 27;
 const asDWORD asBEHAVE_BIT_AND       = 28;
 const asDWORD asBEHAVE_BIT_XOR       = 29;
 const asDWORD asBEHAVE_BIT_SLL       = 30;
 const asDWORD asBEHAVE_BIT_SRL       = 31;
 const asDWORD asBEHAVE_BIT_SRA       = 32;
const asDWORD asBEHAVE_LAST_DUAL     = 32;
const asDWORD asBEHAVE_INDEX         = 33;
const asDWORD asBEHAVE_NEGATE        = 34;
const asDWORD asBEHAVE_ADDREF        = 35;
const asDWORD asBEHAVE_RELEASE       = 36;

// Return codes

const int asSUCCESS                              =  0;
const int asERROR                                = -1;
const int asCONTEXT_ACTIVE                       = -2;
const int asCONTEXT_NOT_FINISHED                 = -3;
const int asCONTEXT_NOT_PREPARED                 = -4;
const int asINVALID_ARG                          = -5;
const int asNO_FUNCTION                          = -6;
const int asNOT_SUPPORTED                        = -7;
const int asINVALID_NAME                         = -8;
const int asNAME_TAKEN                           = -9;
const int asINVALID_DECLARATION                  = -10;
const int asINVALID_OBJECT                       = -11;
const int asINVALID_TYPE                         = -12;
const int asALREADY_REGISTERED                   = -13;
const int asMULTIPLE_FUNCTIONS                   = -14;
const int asNO_MODULE                            = -15;
const int asNO_GLOBAL_VAR                        = -16;
const int asINVALID_CONFIGURATION                = -17;
const int asINVALID_INTERFACE                    = -18;
const int asCANT_BIND_ALL_FUNCTIONS              = -19;
const int asLOWER_ARRAY_DIMENSION_NOT_REGISTERED = -20;
const int asAPP_CANT_INTERFACE_DEFAULT_ARRAY     = -21;

// Context states

const int asEXECUTION_FINISHED      = 0;
const int asEXECUTION_SUSPENDED     = 1;
const int asEXECUTION_ABORTED       = 2;
const int asEXECUTION_EXCEPTION     = 3;
const int asEXECUTION_PREPARED      = 4;
const int asEXECUTION_UNINITIALIZED = 5;
const int asEXECUTION_ACTIVE        = 6;
const int asEXECUTION_ERROR         = 7;

// ExecuteStep flags

const asDWORD asEXEC_STEP_INTO = 0;
const asDWORD asEXEC_STEP_OVER = 1;

// ExecuteString flags

const asDWORD asEXECSTRING_ONLY_PREPARE	  = 1;
const asDWORD asEXECSTRING_USE_MY_CONTEXT = 2;

// Prepare flags

const int asPREPARE_PREVIOUS = -1;

//-----------------------------------------------------------------
// Function pointers

#include <memory.h>

inline asUPtr asFunctionPtr(asFUNCTION_t func)
{
	asUPtr p;
	memset(&p, 0, sizeof(p));
	p.func = func;

	return p;
}

// Method pointers

// Declare a dummy class so that we can determine the size of a simple method pointer
class asCSimpleDummy {};
typedef void (asCSimpleDummy::*asSIMPLEMETHOD_t)();
const int SINGLE_PTR_SIZE = sizeof(asSIMPLEMETHOD_t);

// Define template
template <int N>
struct asSMethodPtr
{
	template<class M>
	static asUPtr Convert(M Mthd)
	{
		// This version of the function should never be executed, nor compiled,
		// as it would mean that the size of the method pointer cannot be determined.
		// int ERROR_UnsupportedMethodPtr[-1];
		return 0;
	}
};

// Template specialization
template <>
struct asSMethodPtr<SINGLE_PTR_SIZE>
{
	template<class M> 
	static asUPtr Convert(M Mthd)
	{
		asUPtr p;
		memset(&p, 0, sizeof(p));

		memcpy(&p, &Mthd, SINGLE_PTR_SIZE);

		return p;
	}
};

#if defined(_MSC_VER) && !defined(__MWERKS__)

// MSVC and Intel uses different sizes for different class method pointers
template <>
struct asSMethodPtr<SINGLE_PTR_SIZE+1*sizeof(int)>
{
	template <class M>
	static asUPtr Convert(M Mthd)
	{
		asUPtr p;
		memset(&p, 0, sizeof(p));

		memcpy(&p, &Mthd, SINGLE_PTR_SIZE+sizeof(int));

		return p;
	}
};

template <>
struct asSMethodPtr<SINGLE_PTR_SIZE+2*sizeof(int)>
{
	template <class M>
	static asUPtr Convert(M Mthd)
	{
		// This is where a class with virtual inheritance falls

		// Since method pointers of this type doesn't have all the 
		// information we need we force a compile failure for this case.
		int ERROR_VirtualInheritanceIsNotAllowedForMSVC[-1];

		// The missing information is the location of the vbase table,
		// which is only known at compile time.

		// You can get around this by forward declaring the class and 
		// storing the sizeof its method pointer in a constant. Example:

		// class ClassWithVirtualInheritance;
		// const int ClassWithVirtualInheritance_workaround = sizeof(void ClassWithVirtualInheritance::*());

		// This will force the compiler to use the unknown type 
		// for the class, which falls under the next case

		asUPtr p;
		return p;
	}
};

template <>
struct asSMethodPtr<SINGLE_PTR_SIZE+3*sizeof(int)>
{
	template <class M>
	static asUPtr Convert(M Mthd)
	{
		asUPtr p;
		memset(&p, 0, sizeof(p));

		memcpy(&p, &Mthd, SINGLE_PTR_SIZE+3*sizeof(int));

		return p;
	}
};

#endif




#endif

